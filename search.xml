<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Config-Center说明]]></title>
    <url>%2F2019%2F08%2F29%2FConfig-Center%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[1.MySqL说明1).游戏游戏状态(status)需按渠道进行独立控制;其他控制项:标签(tag),在线人数(line_base_number),在人数波动最小值(line_min_volatility),在线人数波动最大值(line_max_volatility)则直接由一组控制项控制； 因此，游戏拆分成两个表: 基础数据表(t_game_base)id,channel,type,name,status,create_time. 游戏配置表(t_game_config)id,game_type,tag,line_base_number,line_min_volatility,line_max_volatility,flag. 2).房间房间状态(status)需要按照渠道进行独立控制；其他一些房间的基本属性是通用的也不推荐进行个性化设置，因此房间也拆分成两个表： 基础数据表(t_room_base)id,channel,game_type,type,status,name,create_time. 游戏配置表(t_room_config)id,room_type,room_usage,room_limit,ratio,notice,tax,min_count,max_count,match_delay,robot_min_count,robot_max_count,max_round,poker_count,gendealer_type,gen_dealer_choices,valid_wagers,single_max_hong,virtual_count,role_max_wager,ext_data. 3).平台平台级控制项分为两类，一类是杀数控制，一类是各项平台级配置，因此分为两个表： 杀数配置表(t_platform_kill)id,kill_number,kill_region_number,kill_role_number,kill_continuous_win_rate_upper_limit,kill_continuous_win_rate_lower_limit 系统配置表(t_platform_setting)id,withdraw,maintain,client_line_list,platform_line_list,platform_transfer_list]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-chess</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分区]]></title>
    <url>%2F2019%2F08%2F14%2FRedis%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Redis分区分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。分区的优势 通过利用多台计算机内存的和值，允许我们构造更大的数据库。 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。 分区的不足redis的一些特性在分区方面表现的不是很好: 涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。 涉及多个key的redis事务不能使用。 当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。 增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。 分区类型Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。 范围分区最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。 哈希分区另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单： 用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。 对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
